<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Deer Render</title>
  </head>
  <body>
    <div id="deer" style="overflow:hidden;"></div>
  </body>
  <script type="text/javascript" src="js/jquery-2.1.4.min.js" ></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r14/Stats.min.js"></script>
  <script type="text/javascript" src="js/three.min.js"></script>
  <script type="text/javascript" src="js/orbitControls.js"></script>
  <style>
    body:hover{
      cursor: crosshair;
    }
  </style>
  <script>
    $( document ).ready(function() {
      $(function(){

        /*global variables*/
        var scene, camera, renderer;
        var controls, guiControls, datGUI;
        var stats;
        var spotLight, hemi;
        var SCREEN_WIDTH, SCREEN_HEIGHT;
        var loader, model, object;

        function init(){
            /*creates empty scene object and renderer*/

            //webgl to canvas fallback
            function webglAvailable() {
          		try {
          			var canvas = document.createElement( 'canvas' );
          			return !!( window.WebGLRenderingContext && (
          				canvas.getContext( 'webgl' ) ||
          				canvas.getContext( 'experimental-webgl' ) )
          			);
          		} catch ( e ) {
          			return false;
          		}
          	}

          	if ( webglAvailable() ) {
          		renderer = new THREE.WebGLRenderer();
              console.log('deer is using webgl');
          	} else {
          		renderer = new THREE.CanvasRenderer();
              console.log('deer is using canvas');
          	}

            scene = new THREE.Scene();
            camera =  new THREE.PerspectiveCamera(45, window.innerWidth*0.95/window.innerHeight*0.95 , .1, 500);

            renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});


            //this is the backgroud color underneath
            renderer.setClearColor(0x000000, 0);
            renderer.setSize(window.innerWidth*0.95, window.innerHeight*0.95);
            renderer.shadowMapEnabled= false;
            renderer.shadowMapSoft = false;




            /*add controls*/
            //controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventListener( 'change', render );

            //renderer.domElement.style.position="absolute";
            //renderer.domElement.style.border="1px solid lime";

            /*
            camera.position.x = 43;
            camera.position.y = -5;
            camera.position.z = 15;
            */

            camera.position.set(43,-5,15);
            camera.lookAt(scene.position);


            /*datGUI controls object*/
            guiControls = new function(){
                this.rotationX  = 0.0;
                this.rotationY  = 0.0;
                this.rotationZ  = 0.0;

                this.lightX = -60;
                this.lightY = 0;
                this.lightZ = 5;
                this.intensity = 2.5;
                this.distance = 373;
                this.angle = 1.6;
                this.exponent = 38;
                this.shadowCameraNear = 34;
                this.shadowCameraFar = 2635;
                this.shadowCameraFov = 68;
                this.shadowCameraVisible=false;
                this.shadowMapWidth=512;
                this.shadowMapHeight=512;
                this.shadowBias=0.00;
                this.shadowDarkness=0.11;

            }
            //hemi = new THREE.HemisphereLight(0xbbbbbb, 0x0099FF);
            hemi = new THREE.HemisphereLight(0xFE5F55, 0x0099FF);


            scene.add(hemi);

            /*adds spot light with starting parameters*/
            spotLight = new THREE.SpotLight(0xffffff);
            spotLight.castShadow = true;
            spotLight.position.set (20, 35, 40);
            spotLight.intensity = guiControls.intensity;
            spotLight.distance = guiControls.distance;
            spotLight.angle = guiControls.angle;
            spotLight.exponent = guiControls.exponent;
            spotLight.shadowCameraNear = guiControls.shadowCameraNear;
            spotLight.shadowCameraFar = guiControls.shadowCameraFar;
            spotLight.shadowCameraFov = guiControls.shadowCameraFov;
            spotLight.shadowCameraVisible = guiControls.shadowCameraVisible;
            spotLight.shadowBias = guiControls.shadowBias;
            spotLight.shadowDarkness = guiControls.shadowDarkness;
            scene.add(spotLight);

            /*add loader call add model function*/
            loader = new THREE.JSONLoader();
            loader.load( 'materialTest4.json', addModel );

            /*adds controls to scene*/
            datGUI = new dat.GUI();
            datGUI.domElement.style.display ='none';
            datGUI.add(guiControls, 'lightX',-60,180);
            datGUI.add(guiControls, 'lightY',0,180);
            datGUI.add(guiControls, 'lightZ',-60,180);

            datGUI.add(guiControls, 'intensity',0.01, 5).onChange(function(value){
                spotLight.intensity = value;
            });
            datGUI.add(guiControls, 'distance',0, 1000).onChange(function(value){
                spotLight.distance = value;
            });
            datGUI.add(guiControls, 'angle',0.001, 1.570).onChange(function(value){
                spotLight.angle = value;
            });
            datGUI.add(guiControls, 'exponent',0 ,50 ).onChange(function(value){
                spotLight.exponent = value;
            });
            datGUI.add(guiControls, 'shadowCameraNear',0,100).name("Near").onChange(function(value){
                spotLight.shadowCamera.near = value;
                spotLight.shadowCamera.updateProjectionMatrix();
            });
            datGUI.add(guiControls, 'shadowCameraFar',0,5000).name("Far").onChange(function(value){
                spotLight.shadowCamera.far = value;
                spotLight.shadowCamera.updateProjectionMatrix();
            });
            datGUI.add(guiControls, 'shadowCameraFov',1,180).name("Fov").onChange(function(value){
                spotLight.shadowCamera.fov = value;
                spotLight.shadowCamera.updateProjectionMatrix();
            });
            datGUI.add(guiControls, 'shadowCameraVisible').onChange(function(value){
                spotLight.shadowCameraVisible = value;
                spotLight.shadowCamera.updateProjectionMatrix();
            });
            datGUI.add(guiControls, 'shadowBias',0,1).onChange(function(value){
                spotLight.shadowBias = value;
                spotLight.shadowCamera.updateProjectionMatrix();
            });
            datGUI.add(guiControls, 'shadowDarkness',0,1).onChange(function(value){
                spotLight.shadowDarkness = value;
                spotLight.shadowCamera.updateProjectionMatrix();
            });
            datGUI.close();
            $("#deer").append(renderer.domElement);
            /*stats*/
            stats = new Stats();

            stats.domElement.style.display = 'none';
            stats.domElement.style.left = '8px';
            stats.domElement.style.top = '8px';
            $("#deer").append( stats.domElement );
        }

        function addModel( geometry,  materials ){
          model = new THREE.Mesh( geometry );
          var material = new THREE.MeshFaceMaterial( materials );
          model = new THREE.Mesh( geometry, material );
          /*
            var material = new THREE.MeshFaceMaterial( materials );

            //model = new THREE.Mesh( geometry,  new THREE.MeshFaceMaterial( materials ) );
          */
            model.scale.set (13,13,13);
            model.position.set (0,0,0);
            //model.rotation.set (0.5,2.5,-0.9,'XYZ');

            //this code beneath is the best method yet
            //although i need to optimize the light sources and intensity
            //model.rotation.set (0.6,2.5,-1.2,'XYZ');

            var bbox = new THREE.BoundingBoxHelper( );
            var yo = new THREE.GeometryUtils.center( geometry )
            //scene.add( bbox );


            scene.add( model );
            var axis = new THREE.AxisHelper(10);
            model.rotation.y = 0.8 * Math.PI;

            //scene.add(axis);

        }

        function render() {
            spotLight.position.x = guiControls.lightX;
            spotLight.position.y = guiControls.lightY;
            spotLight.position.z = guiControls.lightZ;

        }

        function animate(){
            requestAnimationFrame(animate);
            render();
            stats.update();
            renderer.render(scene, camera);
        }
        init();
     animate();


        $(window).resize(function(){
            SCREEN_WIDTH = window.innerWidth*0.95;
            SCREEN_HEIGHT = window.innerHeight*0.95;
            camera.aspect = SCREEN_WIDTH*0.95 / SCREEN_HEIGHT*0.95;
            camera.updateProjectionMatrix();
            renderer.setSize( SCREEN_WIDTH*0.95, SCREEN_HEIGHT*0.95 );
        });

      });

});

</script>
</html>
